<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medical Q&A Dataset Generator</title>
    <style>
        /* General Body and Container Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a3a 0%, #2e3d4e 100%); /* Deep charcoal to dark blue gradient */
            min-height: 100vh;
            color: #e0e0e0; /* Lighter text for dark background */
            display: flex;
            flex-direction: column; /* Allow content to flow vertically */
            justify-content: flex-start; /* Align content to the top */
            align-items: center; /* Center horizontally */
            padding: 20px;
            /* Removed overflow: hidden; to allow scrolling */
            position: relative;
        }

        /* Animated Background Elements */
        .background-animated-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #0f1c2b, #1e3048, #0f1c2b, #1e3048);
            background-size: 400% 400%;
            animation: backgroundGradient 15s ease infinite;
            z-index: -1; /* Send to back */
            opacity: 0.8;
        }

        @keyframes backgroundGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1000px;
            width: 100%;
            margin: 0 auto; /* Keep auto margins for horizontal centering */
            background: rgba(255, 255, 255, 0.05); /* Very subtle transparency */
            backdrop-filter: blur(10px); /* Lighter blur for performance/subtlety */
            border-radius: 20px; /* Slightly less rounded for a crisper feel */
            padding: 45px; /* More padding */
            box-shadow: 0 20px 40px rgba(0,0,0,0.5), inset 0 0 0 1px rgba(255,255,255,0.05); /* Stronger shadow, subtle inner border */
            border: 1px solid rgba(255,255,255,0.05);
            position: relative; /* For z-index over background */
            flex-shrink: 0; /* Prevent shrinking if content is too large */
            margin-top: 20px; /* Add some top margin to distance from top of viewport */
            margin-bottom: 20px; /* Add some bottom margin */
        }

        /* Header Styles */
        .header {
            text-align: center;
            color: #ffffff;
            margin-bottom: 50px;
            text-shadow: 0 4px 8px rgba(0,0,0,0.5); /* Deeper text shadow */
        }

        .header h1 {
            font-size: 3.8rem; /* Even larger */
            margin-bottom: 15px;
            letter-spacing: 0.08em; /* More spaced out */
            font-weight: 700;
        }

        .header p {
            font-size: 1.5rem;
            opacity: 0.9;
            font-weight: 300;
        }

        /* Card Section Styles (Glassmorphism inspired) */
        .card-section {
            background: rgba(255, 255, 255, 0.03); /* Very subtle card background */
            border-radius: 18px; /* Consistent rounding */
            padding: 35px;
            margin-bottom: 35px; /* Increased margin between cards */
            box-shadow: 0 5px 15px rgba(0,0,0,0.3), inset 0 0 0 1px rgba(255,255,255,0.02); /* Softer card shadow */
            border: 1px solid rgba(255,255,255,0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.3s ease;
        }

        .card-section:hover {
            transform: translateY(-10px); /* More pronounced lift */
            box-shadow: 0 15px 30px rgba(0,0,0,0.5), inset 0 0 0 1px rgba(255,255,255,0.05);
            background: rgba(255, 255, 255, 0.05); /* Slightly brighter on hover */
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 30px; /* More space */
            cursor: pointer;
            padding-bottom: 25px; /* More padding */
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .card-header h3 {
            font-size: 2.2rem; /* Larger heading */
            color: #e0e0e0;
            margin: 0;
            display: flex;
            align-items: center;
            font-weight: 600;
            letter-spacing: 0.02em;
        }

        .card-header h3 .icon {
            font-size: 2.5rem; /* Larger icon */
            margin-right: 18px; /* More space */
            color: #66b2ff; /* Bright blue accent */
        }

        .toggle-icon {
            font-size: 2.2rem;
            color: #66b2ff;
            transition: transform 0.3s ease;
        }

        .card-content {
            display: block;
            overflow: hidden;
            transition: max-height 0.6s ease-out; /* Smoother collapse/expand */
            max-height: 1500px; /* Increased for more content */
            padding-top: 15px; /* Space between header border and content */
        }

        .card-section.collapsed .card-content {
            max-height: 0;
            padding-top: 0;
            margin-bottom: 0; /* No bottom margin when collapsed */
        }

        .card-section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        /* Form Group & Inputs - FOCUS ON SPACING */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Adjusted min-width for larger inputs */
            gap: 45px; /* SIGNIFICANTLY INCREASED GAP for ample horizontal space */
            margin-bottom: 20px; /* Add some space below the grid itself */
        }
        /* Ensure consistent vertical spacing for individual form groups */
        .form-group {
            margin-bottom: 40px; /* INCREASED VERTICAL SPACING below each form group */
        }
        /* Remove bottom margin for the last form-group within a grid for clean alignment */
        .form-grid > .form-group:last-child,
        .form-grid > .form-group:nth-last-child(2) { /* Covers the case of two columns in the last row */
            margin-bottom: 0;
        }
        /* For single form groups not in a grid (like the textarea) */
        .card-content > .form-group:last-child {
            margin-bottom: 0;
        }


        label {
            display: block;
            margin-bottom: 15px; /* INCREASED space below label */
            font-weight: 500;
            color: #b0b0b0;
            font-size: 1.15rem; /* Slightly larger label text */
        }

        input[type="text"],
        input[type="email"],
        input[type="number"],
        input[type="url"],
        textarea,
        select {
            width: 100%;
            padding: 18px; /* Generous padding */
            border: 1px solid rgba(255,255,255,0.15); /* Subtle border */
            border-radius: 15px; /* More rounded */
            font-size: 17px; /* Larger text */
            transition: all 0.3s ease;
            background: rgba(0,0,0,0.25); /* Dark, slightly transparent input background */
            color: #ffffff; /* White text in inputs */
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3); /* Inner shadow for depth */
        }

        input::placeholder, textarea::placeholder {
            color: #a0a0a0;
            opacity: 0.7;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #8cc4ff; /* Brighter focus blue */
            box-shadow: 0 0 0 6px rgba(130, 196, 255, 0.4), inset 0 2px 5px rgba(0,0,0,0.5); /* Wider, deeper focus shadow */
            background: rgba(0,0,0,0.35); /* Darker on focus */
            transform: scale(1.005); /* Very subtle grow effect */
        }

        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20256%20256%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M208.5%2088.5L128%20169L47.5%2088.5Z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 20px center; /* Adjusted for larger padding */
            background-size: 20px; /* Larger arrow */
        }

        textarea {
            min-height: 180px; /* Even taller textarea */
            resize: vertical;
        }

        /* File Upload Area */
        .upload-area {
            border: 3px dashed rgba(102, 178, 255, 0.5); /* More prominent dashed border */
            border-radius: 20px;
            padding: 45px; /* More padding */
            text-align: center;
            cursor: pointer;
            background: rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.4); /* Inner shadow */
        }

        .upload-area:hover {
            border-color: #66b2ff;
            background: rgba(0,0,0,0.2);
            transform: translateY(-8px); /* More pronounced lift */
            box-shadow: 0 10px 25px rgba(0,0,0,0.5), inset 0 2px 8px rgba(0,0,0,0.5);
        }
        .upload-area.dragover {
            border-color: #5cb85c;
            background: rgba(0,0,0,0.3);
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 4.5rem; /* Even larger icon */
            color: #66b2ff;
            margin-bottom: 25px;
        }

        .upload-text p {
            font-size: 1.3rem; /* Larger text */
            color: #ffffff;
            font-weight: 500;
        }
        .upload-text small {
            font-size: 1.05rem; /* Larger small text */
            color: #b0b0b0;
            margin-top: 10px; /* More space */
        }

        .file-list {
            margin-top: 30px; /* More space */
            text-align: left;
            background: rgba(0,0,0,0.15); /* Darker background */
            border-radius: 18px;
            padding: 25px; /* More padding */
            max-height: 300px; /* Taller scrollable list */
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: inset 0 1px 5px rgba(0,0,0,0.3);
        }

        .file-item {
            background: rgba(255,255,255,0.08); /* Darker item background */
            padding: 15px 20px; /* More padding */
            border-radius: 15px;
            margin-bottom: 12px; /* More space */
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 8px solid #66b2ff; /* Thicker, brighter accent */
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #ffffff;
            font-size: 1rem;
            font-weight: 400;
        }
        .file-item:last-child {
            margin-bottom: 0;
        }

        .file-item .file-name {
            flex: 1;
            font-weight: 500;
            white-space: nowrap; /* Prevent breaking filename */
            overflow: hidden;
            text-overflow: ellipsis; /* Add ellipsis if too long */
            margin-right: 15px;
        }

        .remove-file-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 18px; /* Larger padding */
            border-radius: 12px;
            font-size: 1.05rem;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .remove-file-btn:hover {
            background-color: #c0392b;
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.3);
        }

        /* Checkbox Group */
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 30px; /* More space */
            gap: 15px;
            cursor: pointer;
        }
        .checkbox-group label {
            margin-bottom: 0;
            font-weight: 400;
            color: #e0e0e0;
            font-size: 1.15rem;
        }
        .checkbox-group input[type="checkbox"] {
            width: 26px; /* Larger checkbox */
            height: 26px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.3);
            background-color: rgba(0,0,0,0.2);
        }
        .checkbox-group input[type="checkbox"]:checked {
            background-color: #66b2ff;
            border-color: #66b2ff;
        }
        .checkbox-group input[type="checkbox"]:checked::after {
            font-size: 20px; /* Larger checkmark */
        }
        .checkbox-group input[type="checkbox"]:focus {
            box-shadow: 0 0 0 5px rgba(102, 178, 255, 0.4);
        }

        /* Buttons */
        .btn {
            background: linear-gradient(45deg, #66b2ff, #4a90e2);
            color: white;
            border: none;
            padding: 20px 45px; /* Even more padding */
            border-radius: 18px; /* More rounded */
            font-size: 1.3rem; /* Larger text */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 25px rgba(74, 144, 226, 0.4); /* Stronger shadow */
        }
        .btn:hover {
            transform: translateY(-8px); /* More pronounced lift */
            box-shadow: 0 15px 35px rgba(74, 144, 226, 0.5);
            background: linear-gradient(45deg, #4a90e2, #66b2ff);
        }
        .btn:disabled {
            background: #5c6a7a;
            color: #a0a0a0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            pointer-events: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            box-shadow: 0 10px 25px rgba(46, 204, 113, 0.4);
        }
        .btn-secondary:hover {
            background: linear-gradient(45deg, #2ecc71, #27ae60);
            box-shadow: 0 15px 35px rgba(46, 204, 113, 0.5);
        }

        .btn-download {
            background: linear-gradient(45deg, #3498db, #2980b9);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.4);
            font-size: 1.1rem;
            padding: 16px 32px; /* Larger padding */
            border-radius: 15px;
        }
        .btn-download:hover {
            box-shadow: 0 12px 25px rgba(52, 152, 219, 0.5);
        }

        /* Toast Notification Container */
        #toast-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10000; /* High z-index to be on top of everything */
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; /* Allows clicks to pass through */
        }

        .toast-message {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateX(-100%);
            animation: fadeInOutToast 5s forwards; /* Animation duration for the toast */
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            font-weight: 500;
        }

        .toast-success {
            background: linear-gradient(90deg, #28a745, #218838);
        }
        .toast-error {
            background: linear-gradient(90deg, #dc3545, #c82333);
        }
        .toast-info {
            background: linear-gradient(90deg, #007bff, #0056b3);
        }
        .toast-testing {
            background: linear-gradient(90deg, #ffc107, #e0a800);
            color: #333;
        }

        @keyframes fadeInOutToast {
            0% { opacity: 0; transform: translateX(-100%); }
            10% { opacity: 1; transform: translateX(0); }
            90% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(-100%); }
        }

        .toast-icon {
            font-size: 1.5em;
        }

        /* Progress Section */
        .progress-container {
            display: none;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 40px; /* More padding */
            margin-top: 35px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.2), inset 0 0 0 1px rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.05);
            text-align: center;
        }

        .progress-container h3 {
            font-size: 2.2rem;
            color: #e0e0e0;
            margin-bottom: 35px;
        }

        .progress-bar {
            width: 100%;
            height: 35px; /* Taller bar */
            background: rgba(0,0,0,0.3); /* Darker background */
            border-radius: 20px; /* More rounded */
            overflow: hidden;
            margin-bottom: 30px; /* More space */
            position: relative;
            box-shadow: inset 0 3px 10px rgba(0,0,0,0.5);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #66b2ff, #4a90e2);
            width: 0%;
            transition: width 0.8s cubic-bezier(0.25, 0.8, 0.25, 1); /* Slower, smoother transition */
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1.2rem; /* Larger text */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }

        .progress-info {
            font-weight: 500;
            color: #b0b0b0;
            margin-bottom: 15px; /* More space */
            font-size: 1.2rem;
        }
        .progress-info span {
            color: #ffffff;
            font-weight: 600;
        }
        .progress-message {
            font-size: 1.1rem;
            color: #d0d0d0;
        }

        /* Results Section */
        .results-container {
            display: none;
            background: linear-gradient(135deg, #28a745, #218838);
            border-radius: 20px;
            padding: 45px;
            margin-top: 35px;
            box-shadow: 0 10px 25px rgba(40, 167, 69, 0.5);
            border: 1px solid #28a745;
            text-align: center;
            color: white;
        }

        .results-container h3 {
            font-size: 2.5rem; /* Larger */
            color: #ffffff;
            margin-bottom: 35px;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.5);
        }

        .results-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); /* Slightly wider stats cards */
            gap: 30px; /* More space */
            margin-bottom: 35px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.12); /* Brighter translucent white */
            padding: 30px; /* More padding */
            border-radius: 18px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.18);
            color: #ffffff;
        }

        .stat-number {
            font-size: 3.2rem; /* Even larger numbers */
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 10px;
            text-shadow: 1px 1px 5px rgba(0,0,0,0.6);
        }

        .stat-label {
            color: #e0e0e0;
            font-size: 1.15rem;
            font-weight: 400;
        }

        .breakdown-info {
            text-align: center;
            margin-top: 30px;
            font-weight: 500;
            color: #e0e0e0;
            line-height: 1.9; /* More line height */
            font-size: 1.05rem;
        }
        .breakdown-info span {
            margin-right: 20px; /* More space between items */
            padding: 8px 15px; /* More padding */
            background: rgba(0,0,0,0.15);
            border-radius: 10px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        .breakdown-info span strong {
            color: #ffffff;
        }

        .download-buttons {
            display: flex;
            gap: 25px; /* More space */
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 50px; /* More margin */
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 10px; /* More space */
            font-size: 1.1em; /* Larger tooltip icon */
            color: #8cc4ff; /* Brighter blue */
            cursor: help;
            vertical-align: middle; /* Align with text */
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 320px; /* Even wider tooltip */
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 12px; /* More rounded */
            padding: 15px; /* More padding */
            position: absolute;
            z-index: 10; /* Ensure it's above other elements */
            bottom: 150%; /* Higher above element */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            opacity: 0;
            transition: opacity 0.4s ease-in-out;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
            white-space: normal; /* Allow text wrapping */
        }

        .tooltip .tooltiptext::after { /* Tooltip arrow */
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="background-animated-gradient"></div>

    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <div class="container">
        <div class="header">
            <h1>üè• Medical Q&A Dataset Generator</h1>
            <p>Craft high-quality, AI-ready question-answer datasets for medical applications</p>
        </div>

        <form id="datasetForm">
            <!-- Basic Configuration Card -->
            <div class="card-section">
                <div class="card-header" onclick="toggleCard(this)">
                    <h3><span class="icon">üìã</span> Basic Configuration</h3>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="card-content">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="email">Email Address (for PubMed API) <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Required for accessing PubMed's research database. Ensure it's a valid email address.</span></span></label>
                            <input type="email" id="email" name="email" required placeholder="your.email@example.com" value="user@example.com">
                        </div>
                        <div class="form-group">
                            <label for="medical_domain">Medical Domain <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Specify the broad medical area (e.g., Cardiology, Oncology). This guides AI generation and file naming.</span></span></label>
                            <input type="text" id="medical_domain" name="medical_domain" required placeholder="e.g., Cardiology, Diabetes, Cancer" value="medical conditions">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="medical_terms">Medical Terms/Keywords (comma-separated) <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Keywords used to filter Q&A from XML files and search for PubMed abstracts. Use specific terms relevant to your dataset.</span></span></label>
                        <textarea id="medical_terms" name="medical_terms" required placeholder="e.g., diabetes, blood sugar, insulin, type 2 diabetes, glucose">cancer, heart disease, covid-19</textarea>
                    </div>
                </div>
            </div>

            <!-- Data Sources Card -->
            <div class="card-section">
                <div class="card-header" onclick="toggleCard(this)">
                    <h3><span class="icon">üìÅ</span> Data Sources</h3>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="card-content">
                    <div class="form-group">
                        <label>PDF Documents (Clinical Guidelines, Research Papers)</label>
                        <div class="upload-area" id="pdfUploadArea" data-type="pdf_files">
                            <span class="upload-icon">üìÑ</span>
                            <div class="upload-text">
                                <p><strong>Drop PDF files here</strong> or click to browse</p>
                                <small>Supports multiple files (.pdf)</small>
                            </div>
                            <input type="file" id="pdfFilesInput" name="pdf_files_input" multiple accept=".pdf" style="display: none;">
                        </div>
                        <div id="pdfFileList" class="file-list"></div>
                    </div>

                    <div class="form-group">
                        <label>XML Files (MedQuAD Format)</label>
                        <div class="upload-area" id="xmlUploadArea" data-type="xml_files">
                            <span class="upload-icon">üìã</span>
                            <div class="upload-text">
                                <p><strong>Drop XML files here</strong> or click to browse</p>
                                <small>MedQuAD formatted XML files (.xml)</small>
                            </div>
                            <input type="file" id="xmlFilesInput" name="xml_files_input" multiple accept=".xml" style="display: none;">
                        </div>
                        <div id="xmlFileList" class="file-list"></div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="use_pubmed" name="use_pubmed" checked>
                        <label for="use_pubmed">Include PubMed abstracts</label>
                        <div class="tooltip">‚ÑπÔ∏è
                            <span class="tooltiptext">Automatically fetch relevant research abstracts from PubMed database based on your medical terms.</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI Configuration Card -->
            <div class="card-section">
                <div class="card-header" onclick="toggleCard(this)">
                    <h3><span class="icon">ü§ñ</span> AI Configuration</h3>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="card-content">
                    <div class="checkbox-group">
                        <input type="checkbox" id="use_ollama" name="use_ollama" checked>
                        <label for="use_ollama">Generate additional Q&A pairs using Ollama AI</label>
                        <div class="tooltip">‚ÑπÔ∏è
                            <span class="tooltiptext">Leverage your local Ollama server to generate more Q&A pairs from the provided text sources. Requires Ollama to be running.</span>
                        </div>
                    </div>
                    
                    <div id="ollamaConfig">
                        <div class="form-grid">
                            <div class="form-group">
                                <label for="ollama_url">Ollama API URL <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">The address of your running Ollama server. Typically http://localhost:11434.</span></span></label>
                                <input type="url" id="ollama_url" name="ollama_url" value="http://localhost:11434" placeholder="http://localhost:11434">
                            </div>
                            <div class="form-group">
                                <label for="ollama_model">Ollama Model <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Select the AI model Ollama will use (e.g., llama3, mistral). Models must be downloaded via Ollama CLI first.</span></span></label>
                                <select id="ollama_model" name="ollama_model">
                                    <option value="">Select a model</option>
                                    <!-- Options will be populated dynamically -->
                                </select>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 30px;">
                            <button type="button" id="testConnection" class="btn btn-secondary">
                                <span class="loading-spinner" style="display:none;"></span> Test Ollama Connection
                            </button>
                            <!-- Connection status will now appear as a toast, not inline here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Generation Parameters Card -->
            <div class="card-section">
                <div class="card-header" onclick="toggleCard(this)">
                    <h3>‚öôÔ∏è Generation Parameters</h3>
                    <span class="toggle-icon">‚ñº</span>
                </div>
                <div class="card-content">
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="target_pairs">Target Total Q&A Pairs <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">The desired total number of Q&A pairs in the final dataset. The system will prioritize MedQuAD, then generate AI pairs to reach this target.</span></span></label>
                            <input type="number" id="target_pairs" name="target_pairs" value="1000" min="100" max="50000">
                        </div>
                        <div class="form-group">
                            <label for="pubmed_retmax">Max PubMed Results <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Maximum number of PubMed abstracts to fetch for text generation. Higher numbers mean longer fetching times.</span></span></label>
                            <input type="number" id="pubmed_retmax" name="pubmed_retmax" value="1000" min="100" max="10000">
                        </div>
                        <div class="form-group">
                            <label for="chunk_size">Text Chunk Size (words) <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Size of text chunks sent to Ollama for Q&A generation. Smaller chunks are faster but may lack context; larger chunks are slower but provide more context.</span></span></label>
                            <input type="number" id="chunk_size" name="chunk_size" value="500" min="100" max="2000">
                        </div>
                        <div class="form-group">
                            <label for="max_workers">Max Parallel Workers (for AI generation) <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Number of concurrent requests to send to Ollama. Adjust based on your system's capabilities (especially GPU) and Ollama server load.</span></span></label>
                            <input type="number" id="max_workers" name="max_workers" value="3" min="1" max="20">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Generate Button -->
            <div style="text-align: center; margin-top: 40px;">
                <button type="submit" id="generateBtn" class="btn">
                    üöÄ Start Dataset Generation
                </button>
            </div>
        </form>

        <!-- Progress Section -->
        <div id="progressContainer" class="progress-container">
            <h3>Generating Your Dataset...</h3>
            <p style="text-align: center; margin-bottom: 10px; font-size: 0.95rem;">Job ID: <span id="jobIdDisplay" style="font-family: monospace; font-weight: bold; color: #a0a0a0;"></span></p>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill">
                    <span id="progressPercentage">0%</span>
                </div>
            </div>
            <div class="progress-info">Status: <span id="jobMessage">Initializing...</span></div>
            <div class="progress-info">Estimated Time Remaining: <span id="estimatedTime">Calculating...</span></div>
        </div>

        <!-- Results Section -->
        <div id="resultsContainer" class="results-container">
            <h3>‚úÖ Dataset Generated Successfully!</h3>
            <div id="resultsStats" class="results-stats"></div>
            <div class="breakdown-info">
                <strong>Source Breakdown:</strong> <span id="sourcesBreakdown"></span>
            </div>
            <div class="breakdown-info" style="margin-top: 10px;">
                <strong>Quality Status:</strong> <span id="qualityBreakdown"></span>
            </div>
            <div class="download-buttons">
                <button id="downloadCsv" class="btn btn-download">üìÑ Download Training CSV</button>
                <button id="downloadJson" class="btn btn-download">üìã Download Full JSON</button>
                <button id="downloadMetadata" class="btn btn-download">üìä Download Metadata CSV</button>
            </div>
        </div>
    </div>

    <script>
        let uploadedFiles = { pdf_files: [], xml_files: [] };
        let currentJobId = null;
        let pollingIntervalId = null;

        // --- Toast Notification Functions ---
        const toastContainer = document.getElementById('toast-container');

        function showToast(message, type = 'info', duration = 4000) { // Default duration 4 seconds
            const toast = document.createElement('div');
            toast.classList.add('toast-message', `toast-${type}`);
            
            let icon = '';
            if (type === 'success') icon = '‚úÖ';
            else if (type === 'error') icon = '‚ùå';
            else if (type === 'info') icon = '‚ÑπÔ∏è';
            else if (type === 'testing') icon = '‚è≥';

            toast.innerHTML = `<span class="toast-icon">${icon}</span> ${message}`;
            toastContainer.prepend(toast); // Add to top of the list

            // Auto-remove after duration
            setTimeout(() => {
                toast.remove();
            }, duration);
        }

        // --- Card Collapse/Expand Toggle ---
        function toggleCard(headerElement) {
            const cardSection = headerElement.closest('.card-section');
            cardSection.classList.toggle('collapsed');
            const toggleIcon = headerElement.querySelector('.toggle-icon');
            if (cardSection.classList.contains('collapsed')) {
                toggleIcon.textContent = '‚ñ∂';
            } else {
                toggleIcon.textContent = '‚ñº';
            }
        }

        // --- File Upload Handling ---
        function setupFileUpload(uploadAreaId, fileInputId, fileListId, fileType) {
            const uploadArea = document.getElementById(uploadAreaId);
            const fileInput = document.getElementById(fileInputId);
            const fileList = document.getElementById(fileListId);

            uploadArea.addEventListener('click', () => fileInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                handleFiles(e.dataTransfer.files, fileType, fileList);
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files, fileType, fileList);
            });
        }

        async function handleFiles(files, fileType, fileListElement) {
            if (files.length === 0) {
                return;
            }

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append(fileType, files[i]);
            }

            showToast(`Uploading ${files.length} ${fileType.replace('_files', '').toUpperCase()} file(s)...`, 'info');

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (response.ok) {
                    uploadedFiles[fileType] = [...uploadedFiles[fileType], ...data[fileType]];
                    updateFileList(fileListElement, uploadedFiles[fileType], fileType);
                    showToast(`Successfully uploaded ${data[fileType].length} ${fileType.replace('_files', '').toUpperCase()} file(s).`, 'success');
                } else {
                    showToast(`Upload failed: ${data.error || 'Unknown error'}`, 'error');
                    console.error('Upload Error:', data.error);
                }
            } catch (error) {
                showToast(`Upload failed due to network error: ${error.message}. Check server connectivity.`, 'error');
                console.error('Upload Error:', error);
            }
        }

        function updateFileList(fileListElement, files, type) {
            fileListElement.innerHTML = '';
            files.forEach((filePath, index) => {
                const fileName = filePath.split('/').pop();
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <span class="file-name">${fileName}</span>
                    <button type="button" class="remove-file-btn" data-filepath="${filePath}" data-type="${type}">√ó</button>
                `;
                fileListElement.appendChild(fileItem);
            });
            fileListElement.querySelectorAll('.remove-file-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const pathToRemove = e.target.dataset.filepath;
                    const typeToRemove = e.target.dataset.type;
                    removeFile(pathToRemove, typeToRemove);
                });
            });
        }

        function removeFile(filePath, fileType) {
            uploadedFiles[fileType] = uploadedFiles[fileType].filter(f => f !== filePath);
            if (fileType === 'pdf_files') {
                updateFileList(document.getElementById('pdfFileList'), uploadedFiles.pdf_files, 'pdf_files');
            } else if (fileType === 'xml_files') {
                updateFileList(document.getElementById('xmlFileList'), uploadedFiles.xml_files, 'xml_files');
            }
            showToast(`File "${filePath.split('/').pop()}" removed from current session's upload list. (File remains stored on the server for historical tracking.)`, 'info');
        }

        // --- Test Ollama connection and populate models ---
        document.getElementById('testConnection').addEventListener('click', async () => {
            const btn = document.getElementById('testConnection');
            const spinner = btn.querySelector('.loading-spinner');
            const modelSelect = document.getElementById('ollama_model');
            
            spinner.style.display = 'inline-block';
            btn.disabled = true;
            showToast('Testing Ollama connection...', 'testing');
            modelSelect.innerHTML = '<option value="">Loading models...</option>';

            try {
                const response = await fetch('/test_ollama', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ollama_url: document.getElementById('ollama_url').value
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showToast(`‚úÖ Connected! Available models: ${result.models.join(', ')}`, 'success');
                    modelSelect.innerHTML = '<option value="">Select a model</option>';
                    result.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        modelSelect.appendChild(option);
                    });
                    if (result.models.length > 0) {
                        modelSelect.value = result.models[0]; // Select the first model by default
                    }
                } else {
                    showToast(`‚ùå Connection failed: ${result.error}`, 'error');
                    modelSelect.innerHTML = '<option value="">Failed to load models</option>';
                }
            } catch (error) {
                showToast(`‚ùå Network error: ${error.message}. Check Flask server connectivity.`, 'error');
                modelSelect.innerHTML = '<option value="">Failed to load models</option>';
            } finally {
                spinner.style.display = 'none';
                btn.disabled = false;
            }
        });

        // Form submission
        document.getElementById('datasetForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Basic client-side validation
            if (!document.getElementById('email').value.trim()) {
                showToast('Email address is required.', 'error');
                return;
            }
            if (!document.getElementById('medical_domain').value.trim()) {
                showToast('Medical domain is required.', 'error');
                return;
            }
            if (!document.getElementById('medical_terms').value.trim()) {
                showToast('Medical terms/keywords are required.', 'error');
                return;
            }
            if (document.getElementById('use_ollama').checked) {
                 if (!document.getElementById('ollama_url').value.trim()) {
                     showToast('Ollama URL is required if AI generation is enabled.', 'error');
                     return;
                 }
                 if (!document.getElementById('ollama_model').value.trim()) {
                     showToast('Ollama Model is required if AI generation is enabled. Please select a model or test connection.', 'error');
                     return;
                 }
            }

            const formData = new FormData(e.target);
            const config = Object.fromEntries(formData.entries());
            
            config.pdf_files = uploadedFiles.pdf_files;
            config.xml_files = uploadedFiles.xml_files;

            config.use_pubmed = document.getElementById('use_pubmed').checked;
            config.use_ollama = document.getElementById('use_ollama').checked;

            config.target_pairs = parseInt(config.target_pairs);
            config.pubmed_retmax = parseInt(config.pubmed_retmax);
            config.chunk_size = parseInt(config.chunk_size);
            config.max_workers = parseInt(config.max_workers);
            
            showProgressUI();
            showToast('Starting dataset generation...', 'info');

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                const result = await response.json();
                
                if (response.ok && result.job_id) {
                    currentJobId = result.job_id;
                    document.getElementById('jobIdDisplay').textContent = currentJobId;
                    startPollingProgress();
                } else {
                    showToast(`Error starting job: ${result.error || 'Unknown error'}`, 'error');
                    hideProgressUI();
                }
            } catch (error) {
                showToast(`Network error: ${error.message}. Could not connect to backend to start generation.`, 'error');
                hideProgressUI();
                console.error('Generate Network Error:', error);
            }
        });

        function showProgressUI() {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('resultsContainer').style.display = 'none';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressPercentage').textContent = '0%';
            document.getElementById('jobMessage').textContent = 'Initializing...';
            document.getElementById('estimatedTime').textContent = 'Calculating...';
        }

        function hideProgressUI() {
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('generateBtn').disabled = false;
        }

        // --- Progress Polling ---
        function startPollingProgress() {
            if (pollingIntervalId) {
                clearInterval(pollingIntervalId);
            }
            pollingIntervalId = setInterval(fetchProgress, 1500);
        }

        async function fetchProgress() {
            if (!currentJobId) return;
            
            try {
                const response = await fetch(`/progress/${currentJobId}`);
                const data = await response.json();

                const progressFill = document.getElementById('progressFill');
                const progressPercentageSpan = document.getElementById('progressPercentage');
                const jobMessageSpan = document.getElementById('jobMessage');
                const estimatedTimeSpan = document.getElementById('estimatedTime');

                if (response.ok) {
                    const percentage = data.percentage;
                    const message = data.message;
                    const status = data.status;
                    const estimatedTimeSeconds = data.estimated_time_remaining_seconds;

                    progressFill.style.width = `${percentage}%`;
                    progressPercentageSpan.textContent = `${percentage}%`;
                    jobMessageSpan.textContent = message;

                    if (status === 'in_progress' && estimatedTimeSeconds !== null) {
                        estimatedTimeSpan.textContent = formatTime(estimatedTimeSeconds);
                    } else if (status === 'completed') {
                        estimatedTimeSpan.textContent = 'Finished!';
                        clearInterval(pollingIntervalId);
                        showResults(data.results);
                        showToast('Dataset generation completed successfully!', 'success');
                    } else if (status === 'error') {
                        estimatedTimeSpan.textContent = 'Error!';
                        clearInterval(pollingIntervalId);
                        showToast(`Generation failed: ${data.results ? data.results.error : 'An unknown error occurred.'}`, 'error');
                        hideProgressUI();
                    } else {
                        estimatedTimeSpan.textContent = 'Calculating...';
                    }

                } else {
                    jobMessageSpan.textContent = `Error fetching progress: ${data.message || 'Unknown error'}`;
                    estimatedTimeSpan.textContent = 'N/A';
                    clearInterval(pollingIntervalId);
                    showToast(`Error fetching progress: ${data.message || 'Job might have failed or does not exist.'}`, 'error');
                    hideProgressUI();
                    console.error('Progress Error:', data.message);
                }
            } catch (error) {
                jobMessageSpan.textContent = `Network error fetching progress: ${error.message}`;
                estimatedTimeSpan.textContent = 'N/A';
                clearInterval(pollingIntervalId);
                showToast(`Network error fetching progress: ${error.message}.`, 'error');
                hideProgressUI();
                console.error('Progress Fetch Error:', error);
            }
        }

        function formatTime(seconds) {
            if (seconds === null || isNaN(seconds) || seconds < 0) {
                return 'N/A';
            }
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.round(seconds % 60);
            if (minutes > 0) {
                return `${minutes} min ${remainingSeconds} sec`;
            }
            return `${remainingSeconds} sec`;
        }

        function showResults(results) {
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('resultsContainer').style.display = 'block';
            document.getElementById('generateBtn').disabled = false;
            
            const statsDiv = document.getElementById('resultsStats');
            const sourcesBreakdownSpan = document.getElementById('sourcesBreakdown');
            const qualityBreakdownSpan = document.getElementById('qualityBreakdown');

            const totalPairs = results.total_pairs;
            const sources = results.sources;
            const qualityBreakdown = results.quality_breakdown;
            
            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${totalPairs}</div>
                    <div class="stat-label">Total Q&A Pairs</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${Object.keys(sources).length}</div>
                    <div class="stat-label">Unique Data Sources</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${sources['Ollama (llama3) from PDF'] || 0}</div>
                    <div class="stat-label">AI from PDF</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${sources['Ollama (llama3) from PubMed'] || 0}</div>
                    <div class="stat-label">AI from PubMed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${sources['MedQuAD'] || 0}</div>
                    <div class="stat-label">MedQuAD Pairs</div>
                </div>
            `;
            
            sourcesBreakdownSpan.innerHTML = Object.entries(sources)
                .map(([source, count]) => `<span><strong>${source}</strong>: ${count} pairs</span>`)
                .join('');

            qualityBreakdownSpan.innerHTML = Object.entries(qualityBreakdown)
                .map(([status, count]) => `<span><strong>${status}</strong>: ${count} pairs</span>`)
                .join('');
            
            // Update download button links
            document.getElementById('downloadCsv').onclick = () => {
                window.open(`/download/${results.csv_file}`);
                showToast(`Downloading ${results.csv_file}`, 'info');
            };
            document.getElementById('downloadJson').onclick = () => {
                window.open(`/download/${results.json_file}`);
                showToast(`Downloading ${results.json_file}`, 'info');
            };
            document.getElementById('downloadMetadata').onclick = () => {
                window.open(`/download/${results.metadata_file}`);
                showToast(`Downloading ${results.metadata_file}`, 'info');
            };
        }

        // Initialize file upload areas
        setupFileUpload('pdfUploadArea', 'pdfFilesInput', 'pdfFileList', 'pdf_files');
        setupFileUpload('xmlUploadArea', 'xmlFilesInput', 'xmlFileList', 'xml_files');

        // Initial check for Ollama config display
        document.getElementById('use_ollama').addEventListener('change', (e) => {
            document.getElementById('ollamaConfig').style.display = e.target.checked ? 'block' : 'none';
        });
        document.getElementById('ollamaConfig').style.display = document.getElementById('use_ollama').checked ? 'block' : 'none';

        // Auto-test Ollama connection on page load (silent if successful)
        document.addEventListener('DOMContentLoaded', () => {
            const testBtn = document.getElementById('testConnection');
            // Trigger the test
            testBtn.click();
            // The showToast in the testConnection function handles visibility
        });
    </script>
</body>
</html>
